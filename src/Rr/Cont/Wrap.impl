//
// Wrap.impl
//
// Created on: 2022-01-22
//     Author: Dmitry Murashov (dmtr <DOT> murashov <AT> <GMAIL>)
//

#include <Rr/Trait/Forward.hpp>
#include <Rr/Util/DefaultConfig.hpp>

namespace Rr {
namespace Cont {
namespace WrapImpl {

// Sfinaes

struct CallIndex {
	template <class T2>
	static auto call(T2 &a) -> decltype(a.at(0))
	{
		a.at(0);
	}
};

struct CallMaxSizeUnderscore {
	template <class T2>
	static auto call(T2 &a) -> decltype(a.max_size())
	{
		return a.max_size();
	}
};

struct CallMaxSizeCamelcase {
	template <class T2>
	static auto call(T2 &a) -> decltype(a.maxSize())
	{
		return a.maxSize();
	}
};

struct CallCapacity {
	template <class T2>
	static auto call (T2 &a) -> decltype(a.capacity())
	{
		return a.capacity();
	}
};

struct CallPush {
	template <class Ti, class Tv>
	static auto call(Ti &aI, Tv &aV) -> decltype(aI.push(aV))
	{
		return aI.push(aV);
	}
};

struct CallPushBackUnderscore {
	template <class Ti, class Tv>
	static auto call(Ti &aI, Tv &aV) -> decltype(aI.push_back(aV))
	{
		return aI.push_back(aV);
	}
};

struct CallPushBackCamelcase {
	template <class Ti, class Tv>
	static auto call(Ti &aI, Tv &aV) -> decltype(aI.pushBack(aV))
	{
		aI.pushBack(aV);
	}
};

struct CallEmplaceBackUnderscore {
	template <class Ti, class Tv>
	static auto call(Ti &aI, Tv &aV) -> decltype(aI.emplace_back(aV))
	{
		aI.emplace_back(aV);
	}
};

struct CallEmplaceBackCamelcase {
	template <class Ti, class Tv>
	static auto call(Ti &aI, Tv &aV) -> decltype(aI.emplaceBack(aV))
	{
		aI.emplaceBack(aV);
	}
};

struct CallBegin {
	template <class Ti>
	static auto call(Ti &aI) -> decltype(aI.begin())
	{
		aI.begin();
	}
};

struct CallEnd {
	template <class Ti>
	static auto call(Ti &&aI) -> decltype(aI.end())
	{
		aI.end();
	}
};

template <class Tv, template <class...> class Tc>
struct GetContainerType {
	static constexpr bool fIndexable = Rr::Refl::CanCallFamily<CallIndex>::check(Rr::Trait::declval<Tc<Tv>>());
	static constexpr bool fKnownCapacity = Rr::Refl::CanCallFamily<CallCapacity,
		CallMaxSizeCamelcase, CallMaxSizeUnderscore>::check(Rr::Trait::declval<Tc<Tv>>());
	static constexpr bool fExpandable = Rr::Refl::CanCallFamily<CallPush, CallPushBackCamelcase, CallPushBackUnderscore,
		CallEmplaceBackCamelcase, CallEmplaceBackUnderscore>::check(Rr::Trait::declval<Tc<Tv>>(), Rr::Trait::declval<Tv>());
	static constexpr bool fHasMethodBegin = Rr::Refl::CanCallFamily<CallBegin>::check(Rr::Trait::declval<Tc<Tv>>());
	static constexpr bool fHasMethodEnd = Rr::Refl::CanCallFamily<CallEnd>::check(Rr::Trait::declval<Tc<Tv>>());

	static constexpr auto value = fExpandable && fHasMethodBegin && fHasMethodEnd ? ContainerType::Push :
		fIndexable && fKnownCapacity ? ContainerType::Index :
		ContainerType::Incompatible;

	static_assert(value != ContainerType::Incompatible, "Incompatible container type");
};

template <class Tv, template <class ...> class Tc>
inline Wrap<ContainerType::Index, Tv, Tc>::Wrap():
	pos{0},
	maxSize(Rr::Refl::CallFamily<CallCapacity, CallMaxSizeUnderscore, CallMaxSizeCamelcase>::call(*((Tc<Tv> *)this)))
{
}

template <class Tv, template <class ...> class Tc>
unsigned Wrap<ContainerType::Index, Tv, Tc>::size() const
{
	return pos;
}

template <class Tv, template <class ...> class Tc>
inline typename Wrap<ContainerType::Index, Tv, Tc>::Iterator
Wrap<ContainerType::Index, Tv, Tc>::begin()
{
	return &this->at(0);
}

template <class Tv, template <class ...> class Tc>
inline typename Wrap<ContainerType::Index, Tv, Tc>::Iterator
Wrap<ContainerType::Index, Tv, Tc>::end()
{
	return (&this->at(0)) + pos;
}

template <class Tv, template <class ...> class Tc>
inline void Wrap<ContainerType::Index, Tv, Tc>::push(const Tv &a)
{
	new (&this->at(pos++), Rr::Object{}) Tv{a};
}

template <class Tv, template <class ...> class Tc>
template <class ...Ts>
inline void Wrap<ContainerType::Index, Tv, Tc>::emplace(Ts &&...aArgs)
{
	new (&this->at(pos++), Rr::Object{}) Tv{Rr::Trait::forward<Ts>(aArgs)...};
}

}  // namespace WrapImpl
}  // namespace Cont
}  // namespace Rr
